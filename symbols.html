<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MYTHS ARE THE PUBLIC DREAM.</title>
  <link rel="stylesheet" href="styles.css">
  <script>
    // Scrolling title text
    const titleText = "MYTHS ARE THE PUBLIC DREAM. ";
    let titleIndex = 0;
    function scrollTitle() {
      document.title = titleText.substring(titleIndex) + titleText.substring(0, titleIndex);
      titleIndex = (titleIndex + 1) % titleText.length;
    }
    setInterval(scrollTitle, 200);
  </script>
</head>
<body>
  <main class="container">
    <a href="myths.html" class="back-link">← Back to myths</a>

    <header class="myths-header">
      <h1 class="myths-title">Symbol Map</h1>
    </header>

    <div class="key-sentence">Archetypal actions, things, places, and ideas that appear across multiple myths, revealing shared symbolic patterns and universal connections.</div>

    <div id="symbolsContainer" class="symbols-container">
      <div class="loading">Loading symbols...</div>
    </div>
  </main>

  <a href="myths.html" class="back-link">← Back to myths</a>

  <footer class="site-footer">
    <p>
      PUBLIC DREAM WORLD is a project by
      <a href="https://adamrgarcia.studio" target="_blank" rel="noopener noreferrer" class="body-link">Adam R Garcia</a>.
      All information and imagery pulled from Wikipedia, which means it's probably not all correct, but a good place to think
      about how we create myths through time, and how they create us in return. "Myth is the public dream and dream is the private myth." —Joseph Campbell
    </p>
  </footer>

  <script src="myths.js"></script>
  <script>
    // Extract words from text, filtering out common words
    const stopWords = new Set([
      'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',
      'from', 'as', 'is', 'was', 'are', 'were', 'been', 'be', 'have', 'has', 'had', 'do', 'does', 'did',
      'will', 'would', 'could', 'should', 'may', 'might', 'must', 'can', 'this', 'that', 'these', 'those',
      'i', 'you', 'he', 'she', 'it', 'we', 'they', 'them', 'his', 'her', 'its', 'our', 'their',
      'what', 'which', 'who', 'whom', 'whose', 'where', 'when', 'why', 'how', 'all', 'each', 'every',
      'some', 'any', 'no', 'not', 'only', 'just', 'also', 'more', 'most', 'very', 'too', 'so', 'than',
      'then', 'now', 'here', 'there', 'up', 'down', 'out', 'off', 'over', 'under', 'again', 'further',
      'once', 'twice', 'first', 'second', 'last', 'next', 'previous', 'other', 'another', 'same', 'different',
      'new', 'old', 'long', 'short', 'big', 'small', 'large', 'little', 'high', 'low', 'good', 'bad',
      'great', 'many', 'much', 'few', 'less', 'more', 'most', 'least', 'better', 'best', 'worse', 'worst'
    ]);

    // Culture names and common proper nouns to exclude
    const cultureNames = new Set([
      'norse', 'hindu', 'mayan', 'yoruba', 'egyptian', 'aztec', 'japanese', 'inuit', 
      'polynesian', 'greek', 'mesopotamian', 'chinese', 'viking', 'ancient', 'classical',
      'pre-colonial', 'post-classic', 'classic', 'period', 'age', 'era'
    ]);

    // Common god/deity names and proper nouns to filter
    const properNouns = new Set([
      'ragnarok', 'pralaya', 'popol', 'vuh', 'obatala', 'anubis', 'izkali', 'yomi',
      'hel', 'kali', 'yuga', 'atum', 'khnum', 'apep', 'mictlan', 'mictlantecuhtli',
      'xibalba', 'izanagi', 'izanami', 'sedna', 'ymir', 'brahma', 'vishnu', 'shiva',
      'manu', 'naraka', 'yama', 'tonatiuh', 'tezcatlipoca', 'quetzalcoatl', 'teotihuacan',
      'hun-came', 'vucub-came', 'hunahpu', 'xbalanque', 'pangu', 'nuwa', 'olodumare',
      'ile-ife', 'rangi', 'papa', 'tane', 'po', 'tiamat', 'apsu', 'marduk', 'enlil',
      'ea', 'kingu', 'utnapishtim', 'gilgamesh', 'atra-hasis', 'enuma', 'elish',
      'valhalla', 'yggdrasil', 'odin', 'loki', 'ra', 'set', 'maat', 'geb', 'nut',
      'shu', 'tefnut', 'charon', 'minos', 'rhadamanthus', 'aeacus', 'elysium',
      'tartarus', 'asphodel', 'persephone', 'deucalion', 'prometheus', 'athena',
      'zeus', 'gaia', 'eros', 'brahman', 'kalki', 'duat', 'ammit', 'apophis',
      'mictecacihuatl', 'hades', 'styx'
    ]);

    function extractWords(text, originalText) {
      if (!text) return [];
      
      // Store original words to detect proper nouns
      const originalWords = originalText ? originalText.split(/\s+/) : [];
      const originalWordSet = new Set(originalWords.map(w => w.toLowerCase().replace(/[^\w]/g, '')));
      
      // Convert to lowercase and extract words
      const words = text.toLowerCase()
        .replace(/[^\w\s]/g, ' ') // Replace punctuation with spaces
        .split(/\s+/)
        .filter(word => {
          // Filter criteria:
          // 1. Length > 3
          // 2. Not a stop word
          // 3. Not a culture name
          // 4. Not a known proper noun
          // 5. Check if it was capitalized in original (likely proper noun)
          if (word.length <= 3) return false;
          if (stopWords.has(word)) return false;
          if (cultureNames.has(word)) return false;
          if (properNouns.has(word)) return false;
          
          // Check if word was capitalized in original text (likely proper noun)
          const capitalized = originalWords.some(orig => {
            const clean = orig.toLowerCase().replace(/[^\w]/g, '');
            return clean === word && orig[0] === orig[0].toUpperCase() && orig[0] !== orig[0].toLowerCase();
          });
          if (capitalized) return false;
          
          return true;
        });
      
      return words;
    }

    function buildSymbolMap() {
      const symbolMap = new Map(); // word -> array of myth objects

      // Process each myth
      myths.forEach(myth => {
        // Combine all text from the myth (excluding culture and title which have proper nouns)
        const allText = [
          myth.summary,
          ...myth.themes,
          myth.type
        ].join(' ');

        // Store original text for proper noun detection
        const originalText = [
          myth.summary,
          ...myth.themes,
          myth.type
        ].join(' ');

        // Extract words (focusing on archetypal concepts, not proper nouns)
        const words = extractWords(allText, originalText);

        // Count occurrences and track which myths contain each word
        const wordSet = new Set(words);
        wordSet.forEach(word => {
          if (!symbolMap.has(word)) {
            symbolMap.set(word, []);
          }
          symbolMap.get(word).push(myth);
        });
      });

      // Filter to only words that appear in 2+ myths
      const crossReferencedSymbols = Array.from(symbolMap.entries())
        .filter(([word, myths]) => myths.length >= 2)
        .sort((a, b) => {
          // Sort by number of myths (descending), then alphabetically
          if (b[1].length !== a[1].length) {
            return b[1].length - a[1].length;
          }
          return a[0].localeCompare(b[0]);
        });

      return crossReferencedSymbols;
    }

    function renderSymbols() {
      const container = document.getElementById('symbolsContainer');
      const symbols = buildSymbolMap();

      if (symbols.length === 0) {
        container.innerHTML = '<div class="empty-state">No cross-referenced symbols found.</div>';
        return;
      }

      // Group symbols by frequency
      const grouped = {};
      symbols.forEach(([word, myths]) => {
        const count = myths.length;
        if (!grouped[count]) {
          grouped[count] = [];
        }
        grouped[count].push({ word, myths });
      });

      // Render symbols
      let html = '<div class="symbols-list">';
      
      // Sort groups by frequency (highest first)
      const sortedGroups = Object.keys(grouped).sort((a, b) => b - a);
      
      sortedGroups.forEach(count => {
        const symbolsInGroup = grouped[count];
        html += `<div class="symbol-group">
          <h2 class="symbol-group-title">Appears in ${count} ${count === 2 ? 'myths' : 'myths'}</h2>
          <div class="symbol-items">`;
        
        symbolsInGroup.forEach(({ word, myths }) => {
          const mythLinks = myths.map(m => 
            `<a href="detail.html?slug=${m.slug}" class="symbol-myth-link">${m.title}</a>`
          ).join(', ');
          
          html += `
            <div class="symbol-item">
              <span class="symbol-word">${word}</span>
              <span class="symbol-myths">${mythLinks}</span>
            </div>
          `;
        });
        
        html += '</div></div>';
      });

      html += '</div>';
      container.innerHTML = html;
    }

    // Render on page load
    renderSymbols();
  </script>
</body>
</html>

